[{"title":"环境配置","date":"2024-09-20T04:49:09.000Z","url":"/2024/09/20/rust%E5%AD%A6%E4%B9%A0/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","tags":[["语言学习","/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"]],"categories":[["Rust","/categories/Rust/"]],"content":"编译器1、Windows首先下载官方编译器，根据自己电脑编译器（MSVC or MinGW）进行配置安装。参考菜鸟教程。 2、Linux没尝试，后期开发会把这块补上 IDE这里选用电脑上有的vscode。需要安装两个插件： CodeLLDB rust-analyzer使用cargo创建项目即可调试和运行代码。 "},{"title":"汇编1","date":"2024-09-20T04:49:09.000Z","url":"/2024/09/20/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%961/","tags":[["二进制","/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"],["汇编","/tags/%E6%B1%87%E7%BC%96/"]],"categories":[["免杀","/categories/%E5%85%8D%E6%9D%80/"],["汇编","/categories/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%96/"]],"content":"进制 [[# 二进制]] 00 01 -&gt; 10 八进制 逢8进1 十进制 逢10进1 1 2 3 4 5 6 7 8 9 -&gt;10 十六进制 逢16进1 六十进制 时钟 0:00 -&gt; 0:59 -&gt; 1:00 二进制 计算机中所有的信息都是以二进制的形式存储的 CPU只认识0和1，即二进制 因为二进制复杂，所以很多软件改用十六进制来简写二进制二进制转十进制 1011010111111 数据宽度位、字节、字是计算机数据存储的单位。位是最小的存储单位，每一个位存储一个1位的二进制码，一个字节由8位组成。而字通常为16、32或64个位组成 位位是最基本的概念，在计算机中，由于只有逻辑0和逻辑1的存在，因此很多东西、动作、数字都要表示为一串二进制，例如：1001 0000 1101等等。其中每一个逻辑0或者1便是一个位。例如这个例子里的 1000 1110共有八个位，它的英文名字叫（bit），是计算机中最基本的单位 字节Byte，是由八个位组成的一个单元，也就是8个bit组成1个Byte。在计算机科学中，用于表示ASCII字符，便是运用字节来记录表示字母和一些符号，例如字符A便用“0100 0001”来表示 字字（Word）代表计算机处理指令或数据的二进制数位数，是计算机进行数据存储和数据处理的运算的单位。对于32位计算机与64位计算机，字的大小往往不同。 32位计算机：1字&#x3D;32位&#x3D;4字节，64位计算机：1字&#x3D;64位&#x3D;8字节 32 DWORD64 QWORD 11位：01110010001 8位：10010001 数学上的数字，是没有大小限制的，可以无限大。但是在计算机中，由于受到硬件的制约，数据是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢掉，不管你存储的是什么数据，在计算机中它最后都是以0，1的形式存储的 假如一个计算机中的数据宽度是4位，它能存储的数据如下 CPU：0和1 0000&#x3D;0 1111&#x3D;15 通用寄存器通用寄存器可用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。除此之外，它们还各自具有一些特殊功能。汇编语言程序员必须熟悉每个寄存器的一般用途和特殊用途，只有这样，才能在程序中做到正确、合理地使用它们。 32位下 EAX：(针对操作数和结果数据的)累加器 ，返回函数结果 ECX：(字符串和循环操作数)计数器 EDX：(I&#x2F;O指针)数据寄存器 EBX：(DS段中的数据指针)基址寄存器 ESP：(SS段中栈指针)栈指针寄存器 EBP：(SS段中栈内数据指针)扩展基址指针寄存器 ESI：(字符串操作源指针)源变址寄存器 EDI：(字符串操作目标指针)目的变址寄存器 64位：RAX 16位：AX 8位：AL 汇编指令 mov: add: sub: and: or: xor: not: MOV r8&#x2F;m8,r8 ADD r&#x2F;m8, imm8 SUB r&#x2F;m8, imm8 AND r&#x2F;m8, imm8 OR r&#x2F;m8, imm8 XOR r&#x2F;m8, imm8 NOT r&#x2F;m8 MOV r16&#x2F;m16,r16 ADD r&#x2F;m16,imm16 SUB r&#x2F;m16,imm16 AND r&#x2F;m16,imm16 OR r&#x2F;m16,imm16 XOR r&#x2F;m16,imm16 NOT r&#x2F;m16 MOV r32&#x2F;m32,r32 ADD r&#x2F;m32,imm32 SUB r&#x2F;m32,imm32 AND r&#x2F;m32,imm32 OR r&#x2F;m32,imm32 XOR r&#x2F;m32,imm32 NOT r&#x2F;m32 MOV r8,r8&#x2F;m8 ADD r&#x2F;m16, imm8 SUB r&#x2F;m16, imm8 AND r&#x2F;m16, imm8 OR r&#x2F;m16, imm8 XOR r&#x2F;m16, imm8 MOV r16,r&#x2F;m16 ADD r&#x2F;m32, imm8 SUB r&#x2F;m32, imm8 AND r&#x2F;m32, imm8 OR r&#x2F;m32, imm8 XOR r&#x2F;m32, imm8 MOV r32,r&#x2F;m32 ADD r&#x2F;m8, r8 SUB r&#x2F;m8, r8 AND r&#x2F;m8, r8 OR r&#x2F;m8, r8 XOR r&#x2F;m8, r8 MOV r8, imm8 ADD r&#x2F;m16, r16 SUB r&#x2F;m16, r16 AND r&#x2F;m16, r16 OR r&#x2F;m16, r16 XOR r&#x2F;m16, r16 MOV r16, imm16 ADD r&#x2F;m32, r32 SUB r&#x2F;m32, r32 AND r&#x2F;m32, r32 OR r&#x2F;m32, r32 XOR r&#x2F;m32, r32 MOV r32, imm32 ADD r8, r&#x2F;m8 SUB r8, r&#x2F;m8 AND r8, r&#x2F;m8 OR r8, r&#x2F;m8 XOR r8, r&#x2F;m8 ADD r16, r&#x2F;m16 SUB r16, r&#x2F;m16 AND r16, r&#x2F;m16 OR r16, r&#x2F;m16 XOR r16, r&#x2F;m16 ADD r32, r&#x2F;m32 SUB r32, r&#x2F;m32 AND r32,r&#x2F;m32 OR r32,r&#x2F;m32 XOR r32,r&#x2F;m32 r 通用寄存器m 代表内存imm 代表立即数r8 代表8位通用寄存器m8 代表8位内存imm8 代表8位立即数 "},{"title":"汇编2","date":"2024-09-20T04:49:09.000Z","url":"/2024/09/20/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%962/","tags":[["二进制","/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"],["汇编","/tags/%E6%B1%87%E7%BC%96/"]],"categories":[["免杀","/categories/%E5%85%8D%E6%9D%80/"],["汇编","/categories/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%96/"]],"content":"内存寻址寄存器位于CPU内部，执行速度快，内存速度相对较慢，但是空间很大。寄存器和内存没有本质区别，都是用于存储数据的容器，都是定宽的 常用的寄存器我们之前提到过有：eax、ecx、edx、ebx、esp、ebp、esi、edi计算机中的几个常用计量单位：BYTE WORD DWORD QWORD#数据宽度是严格限制的，不然无法编译。 BYTE 字节 ＝ 8bitWORD 字 &#x3D; 16bitDWORD 双字 &#x3D; 32bitQWORD &#x3D; 64bit1kb &#x3D; 1024 byte1mb &#x3D; 1024 kb1gb &#x3D; 1024 mb 在计算机里面每一个字节都有一个编号，这里可以认为内存的编号就是字节，在32位下范围为00000000-FFFFFFFF，最大的寻址范围就是FFFFFFFF+1字节(byte)，这里进行转换就是4G 16位 -&gt; 32位 -&gt; 64位 cs ds ss es：在用户层只是起寻址的作用，在内核层（ring0）涉及到段、页会有其他的用途 向指定内存写入数据 ds：data segment register，即数据段寄存器ptr：表示后面是一个指针 lea指令：取地址指令 内存寻址的几种方式第一种：使用立即数 第二种：使用通用寄存器 第三种：使用立即数+通用寄存器 第四种：使用通用寄存器+通用寄存器*1&#x2F;2&#x2F;4&#x2F;8 第五种：使用通用寄存器+通用寄存器*1&#x2F;2&#x2F;4&#x2F;8+立即数 内存寻址.xlsx 标志寄存器x86架构CPU中，标志寄存器主要有3种作用： 存储相关指令执行后的结果，例如CF、PF、AF、ZF、OF标志位 执行相关指令时，提供行为依据，例如执行JE指令时会读取ZF的值，来决定是否进行跳转。 控制CPU的工作方式，例如IF、VM、TF等标志位。 16位模式下，标志寄存器名称为FLAG ，寄存器大小16位。32位模式下，标志寄存器的名称为EFLAG ，寄存器大小32位。64位模式下，标志寄存器的名称为RFLAG ，寄存器大小64位。 EFLAG寄存器各个位有不同的用途，灰色的部分为保留位 eflags.xlsx jcc语句jmpjmp 跳转到指定地址：e9 不涉及堆栈变化 （不修改ebp&amp;esp）本质：修改EIP jmp 0x19FFD0 &#x3D;&gt; mov eip,0x19FFD0 callcall 跳转到指定地址并返回到当前指令的下一行：e8。会涉及堆栈改变 e8：就近跳转ff 15：远跳转 无限地址 esp提升4字节(-) 将返回地址（call的下一行）压入堆栈call 0x19FFD0 &#x3D;&gt; push 0x19FFD4 &#x2F; mov eip,0x19FFD0 retret 返回到指定地址 esp降低4字节(+) 从堆栈里面取出返回地址传给eipret &#x3D;&gt; lea esp, [esp+4] &#x2F; mov eip, [esp-4] cmpcmp 比较两个操作数是否相等 CMP R&#x2F;M,R&#x2F;M&#x2F;IMM其实做的是一个相减的操作相等则ZF&#x3D;1 若eax小于ecx则SF&#x3D;1，若eax大于ecx则SF&#x3D;0 testtest 对两个数进行相与操作 TEST R&#x2F;M,R&#x2F;M&#x2F;IMM两个数相与，用来判断寄存器的值是否为0test eax,eax JCC指令 中文含义 检查符号位 典型C应用 JZ&#x2F;JE 若为0则跳转；若相等则跳转 ZF&#x3D;1 if (i &#x3D;&#x3D; j);if (i&#x3D;&#x3D; 0); JNZ&#x2F;JNE 若不为0则跳转；若不相等则跳转 ZF&#x3D;0 if (i !&#x3D; j);if (i!&#x3D; 0); JS 若为负则跳转 SF&#x3D;1 if (i &lt; 0); JNS 若为正则跳转 SF&#x3D;0 if (i &gt; 0); JP&#x2F;JPE 若1出现次数为偶数则跳转 PF&#x3D;1 (null) JNP&#x2F;JPO 若1出现次数为奇数则跳转 PF&#x3D;0 (null) JO 若溢出则跳转 OF&#x3D;1 (null) JNO 若无溢出则跳转 OF&#x3D;0 (null) JC&#x2F;JB&#x2F;JNAE 若进位则跳转；若低于则跳转；若不高于等于则跳转 CF&#x3D;1 if (i &lt; j); JNC&#x2F;JNB&#x2F;JAE 若无进位则跳转；若不低于则跳转；若高于等于则跳转 CF&#x3D;0 if (i &gt;&#x3D; j); JBE&#x2F;JNA 若低于等于则跳转；若不高于则跳转 ZF&#x3D;1或CF&#x3D;1 if (i &lt;&#x3D; j); JNBE&#x2F;JA 若不低于等于则跳转；若高于则跳转 ZF&#x3D;0或CF&#x3D;0 if (i &gt; j); JL&#x2F;JNGE 若小于则跳转；若不大于等于则跳转 SF !&#x3D; OF if (si &lt; sj); JNL&#x2F;JGE 若不小于则跳转；若大于等于则跳转 SF &#x3D; OF if (si &gt;&#x3D; sj); JLE&#x2F;JNG 若小于等于则跳转；若不大于则跳转 ZF !&#x3D; OF 或ZF &#x3D; 1 if (si&lt;&#x3D; sj); JNLE&#x2F;JG 若不小于等于则跳转；若大于则跳转 SF &#x3D; 0F且ZF &#x3D; 0 if(si &gt; sj) 堆栈一个由C&#x2F;C++编译的程序占用的内存分为以下几个部分 栈区（stack），由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆区（heap） ，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。 全局区（静态区）（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。 常量区，常量字符串就是放在这里的，程序结束后由系统释放。 程序代码区，存放函数体的二进制代码。 堆栈.xlsx 堆栈图.xlsx"},{"title":"汇编3","date":"2024-09-20T04:49:09.000Z","url":"/2024/09/20/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%963/","tags":[["二进制","/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"],["汇编","/tags/%E6%B1%87%E7%BC%96/"]],"categories":[["免杀","/categories/%E5%85%8D%E6%9D%80/"],["汇编","/categories/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%96/"]],"content":"空函数C代码 反汇编 两个数相加C代码 反汇编 三个数相加C代码 反汇编 裸函数裸函数，不生成汇编代码 不能直接执行，需要加上__asm ret 无参数无返回值的框架 有参数有返回值的框架 调用约定__cdecl 从右往左入栈 调用者清理堆栈__stdcall 从右往左入栈 自身清理堆栈__fastcall 将前两个参数用ecx、edx传入，剩下的参数从右往左入栈 自身清理堆栈 __cdecl __stdcall __fastcall 数据宽度主要分为整数类型和浮点类型整数类型:char 8bit 1字节 对应byteshort 16bit 2字节 对应wordint 32bit 4字节 对应dword 有符号数与无符号数在计算机中，数值类型分为整数型或实数型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。在程序中，用户可以自己定义是否需要一个非负整数；用char来举例吧，char占一个字节，一个字节&#x3D;8个二进制位，所以它可以表示2^8个数，也就是256个 数。若想要表示正负号，一般需要一个位来标记，如取最高代表正负号 有符号：0111 1111 &#x3D; 2^6+2^5+2^4+2^3+2^2+2^1+2^0 &#x3D; 127 &#x3D;&#x3D;&gt; 范围是 -128 ~ 127无符号：1111 1111 &#x3D; 2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0 &#x3D; 255 &#x3D;&#x3D;&gt; 范围是 0 ~ 255 ![[Pasted image 20240826001850.png]] ![[Pasted image 20240826001922.png]]![[Pasted image 20240826001927.png]] ![[Pasted image 20240826001949.png]]![[Pasted image 20240826001955.png]] 整数类型又分为有符号数跟无符号数，但是在内存里面是一模一样的 但是运算的时候会有jcc语句的比较 全局变量&#x2F;局部变量全局变量是整个程序都可访问的变量，生存期从程序开始到程序结束；局部变量存在于模块中(比如某个函数)，只有在模块中才可以，生存期从模块开始到模块结束全局变量分配在全局数据段，在程序开始运行的时候被加载，局部变量则分配在程序的堆栈中。因此，操作系统和编译器可以通过内存分配的位置来知道来区分全局变量和局部变量全局变量和局部变量的区别是在存储器中位置不同，具体说，全局变量存储在数据段中，局部变量一般来说在堆栈段 全局变量 全局变量的地址在程序编译时就已经确定，如果没有赋初始值则为0 全局变量可以被所有函数修改，存储的是最后一个函数所附的值 全局变量占用的内存一直会存在，直到进程结束 反汇编：mov 寄存器,dword ptr ds:[0x12345678] 初始化可以不赋初值 局部变量 局部变量没有固定的地址，需要在调用的时候才会在堆栈里面分配内存 局部变量执行完毕之后数据仍然保存在堆栈，但已经没有作用 只能在函数内部使用，不能够跨函数调用 反汇编：mov eax,[esp-4] 初始化必须赋初值 "},{"title":"汇编4","date":"2024-09-20T04:49:09.000Z","url":"/2024/09/20/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%964/","tags":[["二进制","/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"],["汇编","/tags/%E6%B1%87%E7%BC%96/"]],"categories":[["免杀","/categories/%E5%85%8D%E6%9D%80/"],["汇编","/categories/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%96/"]],"content":"数组它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量 数组的定义 读取数组 写入数组 条件语句if底层反汇编与正向代码逻辑相反 if…else if…else if…else 底层反汇编与正向代码逻辑相反 while只要判断条件为真，则一直执行循环底层反汇编与正向代码逻辑相反 do…while与while的区别是至少执行一次循环体底层反汇编与正向代码逻辑相同 forC代码 反汇编 参数传递参数传递的本质：将上层函数的变量，或者表达式的值复制一份，传递给下层函数 C代码 反汇编 结构体数组允许定义可存储相同类型数据项的变量，结构体是C语言中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项 结构体对齐，n为字节对齐，默认为8，可填1、2、4、8，如果n的值比sizeof() 得出的值小，则以n的值对齐，否则以sizeof() 的值对齐结构体的总大小必须是其内部最大成员的整数倍 dll编写DLL的全称是Dynamic Link Library，中文叫做“动态链接文件”，在Windows操作系统中，DLL对于程序执行是非常重要的，因为程序在执行的时候，必须链接到DLL文件，才能够正确地运行。DLL的全称是Dynamic Link Library，中文叫做“动态链接文件”在Windows操作系统中，DLL对于程序执行是非常重要的，因为程序在执行的时候，必须链接到DLL文件, 才能够正确地运行。而有些DLL文件可以被许多程序共用。因此，程序设计人员可以利用DLL文件，使程序不至于太过巨大 vs生成dll， DllMain 的形式其调用流程如下 程序调用Windows API LoadLibrary 操作系统寻找LoadLibrary所加载的DLL文件 操作系统将DLL文件加载至目标程序进程的内存空间 程序自动调用 DllMain函数 程序调用DLL中导出函数 DllMain的成员作用如下 其中 fdwReason用来表示Dll被调用的状态，一共分为四种：DLL_PROCESS_ATTACH 被进程加载DLL_PROCESS_DETACH 被进程释放DLL_THREAD_ATTACH 被线程加载DLL_THREAD_DETACH 被线程释放示例代码 dll加载另外一种方式，可以用rundll32 调用 Rundll32.exe 用来执行32位的DLL文件。它的作用是执行DLL文件中的内部函数，这样在进程当中，只会有 Rundll32.exe ，而不会有DLL后门的进程，这样，就实现了进程上的隐藏。虽然说不会产生额外的进程，但是如果遍历 rundll32.exe 的模块还是能够发现进程加载的dll rundll32.exe 支持的函数原型如下 示例代码 "}]